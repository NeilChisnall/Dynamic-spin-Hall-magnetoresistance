import numpy as np 
from scipy.integrate import solve_bvp
import matplotlib.pyplot as plt 
from numba import jit, njit, vectorize
from scipy.integrate import simps


# define all contstants

rho = 8.6e-7 #resistivity
sigma = 1/rho
lsf = 1.5e-9 #spin-diffusion length
e = 1.602e-19 #electron charge
thetaSH =  0.1 #spin hall angle
Ex = 10 #electromagnetic field strength in the x direction (arbitrary rn)
jSHs0 = thetaSH * Ex / rho #spin current generated by SHE

#experiment parameters

A = - 1 / (2 * rho)
B = e * jSHs0 # spin accumulation at the interface in the absence of spin transfer
C = lsf ** 2

jc0 = sigma * Ex #charge current density
Gr = 5e14#real spin-mixing conductance, 0.0 for single layer/parallel magnetisation
Gi = 5e13j #im spin mixing
G = Gr + Gi
dN = 5e-9 #heavy metal thickness
theta = 45.00 
mx = np.sin(theta * np.pi / 180.00) #magnetisation direction unit vector components
my = -np.cos(theta * np.pi / 180.00)
mz = np.sin(45 * np.pi / 180.00)
m = np.array([mx, my, mz], dtype = np.float64) 
m_hat = m / np.linalg.norm(m)
muSN0 = 2 * e * lsf * rho * jSHs0 * np.tanh(dN / ( 2 * lsf))

# The two coupled diff eq are split into 6 (3per eq) coupled lin equations 

@jit(nopython=True)
def fun(x, y):

    return np.vstack((
        A * y[3] / C,
        A * y[4] / C,
        A * y[5] / C, 
        y[0] / A,
        (y[1] + B) / A,
        y[2] / A
    ))

# def boundary condtions

@jit(nopython=True)
def bc(ya, yb):

    
    mus0 = np.array([ya[3], ya[4], ya[5]])
    eJs0 = Gr * np.cross(m_hat, np.cross(m_hat, mus0)) + np.absolute(Gi) * np.cross(m_hat, mus0)
    return np.array( [ ya[0] - eJs0[0], ya[1] - eJs0[1], ya[2] - eJs0[2], yb[0], yb[1], yb[2] ] )

#precision parameters

n = 100
x = np.linspace(0, dN, n)
y = np.zeros((6, x.size))


def solver():

    soln = solve_bvp(fun, bc, x, y)
    return soln

soln = solver()

if soln.status != 0:
    print("WARNING: sol.status is {}".format(soln.status))
print(soln.message)

# Numeric Jc longitudinal calulation...

z_hat = np.array([0,0,1])

js = np.vstack(( soln.y[0], soln.y[1], soln.y[2])) / e
jcLong = np.zeros((3,n))


def Jc_Numeric():

    for l in range(n):
        jcLong[:,l] = thetaSH * (
            np.cross( js[:,l] , z_hat))

    return jcLong

JcNumeric = Jc_Numeric()
JcLongNumeric = JcNumeric[0,:] + jc0
JcTransNumeric = JcNumeric[1,:]
 
@njit
def integrateJc():

    AvLong = np.sum(JcLongNumeric) / len(JcLongNumeric)
    AvTrans = np.sum(JcTransNumeric) / len(JcTransNumeric)

    return AvLong, AvTrans

AvJcLong , AvJcTrans = integrateJc()
rhoLongNumeric = Ex / AvJcLong
rhoTransNumeric = -AvJcTrans / ( Ex * sigma**2 )

print("The Numeric longitudinal resitivity is: ", rhoLongNumeric )
print("The Numeric transverse resitivity is: ", rhoTransNumeric )

# analyic current density

@jit(nopython=True)
def Jc_Long_Analytic(z):

    j_coeff = ( (2 * lsf * G * np.tanh( (dN) / (2*lsf))) / ( sigma + 2 * lsf * G * (1/np.tanh( (dN) / (lsf) )) ) ) * ( (np.sinh( (z - dN) / (lsf))) / (np.sinh( (dN) / (lsf))))
    JclongAnaly = 1 + thetaSH**2 * ( ( (np.cosh( (2*z - dN) / (2*lsf) ) - np.cosh( (dN) / (2*lsf) ) ) / ( np.cosh( (dN) / (2*lsf) )) ) + (1-m_hat[1]**2) * j_coeff.real )

    return JclongAnaly * jc0

@jit(nopython=True)
def Jc_Trans_Analytic(z):

    j_coeff = ( (2 * lsf * G * np.tanh( (dN) / (2*lsf))) / ( sigma + 2 * lsf * G * (1/np.tanh( (dN) / (lsf) )) ) ) * ( (np.sinh( (z - dN) / (lsf))) / (np.sinh( (dN) / (lsf))))
    JctransAnaly = thetaSH**2 * (m_hat[0] * m_hat[1] * j_coeff.real - m_hat[2] * j_coeff.imag)

    return JctransAnaly * jc0

# analytic resistivity

rho_coeff = ( ( 2*lsf*G*(np.tanh(dN/(2*lsf)))**2 ) / (sigma + 2*lsf*G*(1/np.tanh(dN/lsf))) )
deltaRho0 = - rho * thetaSH**2 * (2*lsf/dN) * np.tanh(dN/(2*lsf))
deltaRho1 = rho *thetaSH**2 * (lsf/dN) * rho_coeff.real
deltaRho2 = - rho * thetaSH**2 * (lsf/dN) * rho_coeff.imag

rhoLongAn =  rho + deltaRho0 + deltaRho1 * (1-m_hat[1]**2)
rhoTransAn = deltaRho1 * m_hat[0] * m_hat[1] + deltaRho2 * m_hat[2]


print("The Analytic longitudinal resitivity is: ", rhoLongAn )
print("The Analytic transverse resitivity is: ", rhoTransAn )
longpercdiff = np.absolute(rhoLongAn - rhoLongNumeric) * 2 / (rhoLongNumeric + rhoLongAn)
transpercdiff = np.absolute(rhoTransAn - rhoTransNumeric) * 2 / (rhoTransNumeric + rhoTransAn)
print( longpercdiff)
print(transpercdiff)


plt.subplot(2,1,1)
plt.plot(x, JcLongNumeric, 'kx', label='$J_{long}^{Numeric}/J{c}^{0}$')
plt.plot(x, Jc_Long_Analytic(x), label='$J_{long}^{Analytic}/J{c}^{0}$')
plt.legend()
plt.ylabel("Jc Longitudinal")
plt.xlabel("z(m)")

plt.subplot(2,1,2)
plt.plot(x, JcTransNumeric, 'kx', label='$J_{trans}^{Numeric}/J{c}^{0}$')
plt.plot(x, Jc_Trans_Analytic(x), label='$J_{trans}^{Analytic}/J{c}^{0}$')
plt.legend()
plt.ylabel("Jc Transverse")
plt.xlabel("y(m)")
plt.show()