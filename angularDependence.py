import numpy as np 
from scipy.integrate import solve_bvp
import matplotlib.pyplot as plt 
from numba import jit, njit
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
from matplotlib.backends.backend_pdf import PdfPages
import matplotlib as mpl
import matplotlib.ticker as tck

plt.rcParams["font.family"] = "Times New Roman"
plt.rcParams['font.size'] = '14'

# define all contstants

rho = 8.6e-7 #resistivity
sigma = 1/rho
lsf = 1.5e-9 #spin-diffusion length
e = 1.602e-19 #electron charge
thetaSH = 0.1 #spin hall angle
Ex = 10 #electromagnetic field strength in the x direction (arbitrary rn)
jSHs0 = thetaSH * Ex / rho #spin current generated by SHE

#experiment parameters

A = - 1 / (2 * rho)
B = e * jSHs0 # spin accumulation at the interface in the absence of spin transfer
C = lsf ** 2

jc0 = sigma * Ex #charge current density
Gr = 5e14#real spin-mixing conductance, 0.0 for single layer/parallel magnetisation
Gi = 5e13j #im spin mixing
G = Gr + Gi
dN = 5e-9 #heavy metal thickness
muSN0 = 2 * e * lsf * rho * jSHs0 * np.tanh(dN / ( 2 * lsf))
z_hat = np.array([0,0,1])

#parameters for solver

n = 100 # the number of points in z js/mu is calculated at for each magnetisation direction
x = np.linspace(0, dN, n)
y = np.zeros((6, x.size))

# def range of theta values

rangeThetaY = [0,180]
rangeThetaZ = [0,180]
nPoints = 100 # number of points between theta limits

thetaY = np.linspace(rangeThetaY[0], rangeThetaY[1], nPoints) * np.pi / 180.00 # Angle to the Y in rads
thetaZ = np.linspace(rangeThetaZ[0], rangeThetaZ[1], nPoints) * np.pi / 180.00 # to the XY plane 

@njit
def bc(ya, yb, m_hat):
    mus0 = np.array([ya[3], ya[4], ya[5]])
    eJs0 = Gr * np.cross(m_hat, np.cross(m_hat, mus0)) + np.absolute(Gi) * np.cross(m_hat, mus0)
    return np.array( [ ya[0] - eJs0[0], ya[1] - eJs0[1], ya[2] - eJs0[2], yb[0], yb[1], yb[2] ] )
    
@njit
def fun(x, y, m_hat):
    return np.vstack((               
    A * y[3] / C,
    A * y[4] / C,
    A * y[5] / C, 
    y[0] / A,
    (y[1] + B) / A,
    y[2] / A
    ))

@njit
def Charge_Current(js):
    Jc = np.zeros((3,n))
    for m in range(n):
        Jc[:,m] = thetaSH * (np.cross( js[:,m] , z_hat))
        return Jc
                

def angular_dependence():
    rhoLongArray = np.zeros((nPoints,nPoints))
    rhoTransArray = np.zeros((nPoints,nPoints))
    for i in range(nPoints):
        mz = np.sin(thetaZ[i])
        for k in range(nPoints):
            mx = np.sin(thetaY[k])
            my = np.cos(thetaY[k])
            m = np.array([mx,my,mz], dtype = np.float64)
            if mx == 1:
                m = np.array([1,0,0])
            if my == 1:
                m = np.array([0,1,0])
            if mz == 1:
                m = np.array([0,0,1])
            m_hat = m / np.linalg.norm(m)
            soln = solve_bvp(lambda x, y: fun(x, y, m_hat), lambda ya, yb: bc(ya, yb, m_hat), x, y)
            js = np.vstack(( soln.y[0], soln.y[1], soln.y[2])) / e
            jc = Charge_Current(js)
            jclong = jc[0, :] + jc0
            jctrans = jc[1, :]
            jcLongAv = np.trapz(jclong, x) / dN
            jcTransAv = np.trapz(jctrans, x) / dN
            rhoLong = Ex / jcLongAv
            rhoTrans = -jcTransAv / ( Ex * sigma**2 )
            rhoLongArray[i, k] = rhoLong
            rhoTransArray[i,k] = rhoTrans
    return rhoLongArray, rhoTransArray

# longresistivity, transresistivity = angular_dependence()

Y = thetaY
Z = thetaZ
Y, Z = np.meshgrid(Y, Z)
RhoLong, RhoTrans = angular_dependence()
RhoLong -= rho
RhoTrans /= 1e-11
RhoLong /= 1e-11

def multiple_formatter(denominator=2, number=np.pi, latex='\pi'):
    def gcd(a, b):
        while b:
            a, b = b, a%b
        return a
    def _multiple_formatter(x, pos):
        den = denominator
        num = np.int(np.rint(den*x/number))
        com = gcd(num,den)
        (num,den) = (int(num/com),int(den/com))
        if den==1:
            if num==0:
                return r'$0$'
            if num==1:
                return r'$%s$'%latex
            elif num==-1:
                return r'$-%s$'%latex
            else:
                return r'$%s%s$'%(num,latex)
        else:
            if num==1:
                return r'$\frac{%s}{%s}$'%(latex,den)
            elif num==-1:
                return r'$\frac{-%s}{%s}$'%(latex,den)
            else:
                return r'$\frac{%s%s}{%s}$'%(num,latex,den)
    return _multiple_formatter
class Multiple:
    def __init__(self, denominator=2, number=np.pi, latex='\pi'):
        self.denominator = denominator
        self.number = number
        self.latex = latex
    def locator(self):
        return plt.MultipleLocator(self.number / self.denominator)
    
    def formatter(self):
        return plt.FuncFormatter(multiple_formatter(self.denominator, self.number, self.latex))
#Longitudinal
fig = plt.figure(figsize=(6.4, 3.5))

ax1 = fig.add_subplot(1,2,1, projection='3d')
surf = ax1.plot_surface(Y, Z, RhoLong, cmap=cm.coolwarm,linewidth=0.5, antialiased=False)
ax1.set_xlabel(r'$\theta$', labelpad=0)
ax1.set_ylabel(r'$\phi$', labelpad=0)
ax1.set_xticks([0, np.pi/2, np.pi])
ax1.set_yticks([0.0, np.pi/2, np.pi])
ax1.set_zticks([0.0 ,1.0,2.0, 3.0])
# ax1.set_zticklabels([0,1,2])
ax1.set_zlabel(r'$\Delta\rho_{xx}$ ($10^{-11} \cdot \Omega m$)', labelpad=10)
ax1.zaxis.set_major_formatter(FormatStrFormatter('%.1f'))
ax1.xaxis.set_major_locator(plt.MultipleLocator(np.pi / 2))
ax1.xaxis.set_minor_locator(plt.MultipleLocator(np.pi / 6))
ax1.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter()))
ax1.yaxis.set_major_locator(plt.MultipleLocator(np.pi / 2))
ax1.yaxis.set_minor_locator(plt.MultipleLocator(np.pi / 6))
ax1.yaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter()))
ax1.zaxis.set_minor_locator(plt.MultipleLocator(0.5))
ax1.tick_params(axis='x', which='major', pad=-5)
ax1.tick_params(axis='y', which='major', pad=-5)

#transverse
ax2 = fig.add_subplot(1,2,2, projection='3d')
surf = ax2.plot_surface(Y, Z, RhoTrans, cmap=cm.coolwarm,linewidth=5, antialiased=False)
ax2.set_xticks([0, np.pi/2, np.pi])
ax2.set_yticks([0.0, np.pi/2, np.pi])
ax2.set_zlabel(r'$\Delta\rho_{xy}$ ($ 10^{-11} \cdot \Omega m$)', labelpad=10)
ax2.set_xlabel(r'$\theta$', labelpad=0)
ax2.set_ylabel(r'$\phi$', labelpad=0)
ax2.set_xticks([0, np.pi/2, np.pi])
ax2.set_yticks([0.0, np.pi/2, np.pi])
ax2.set_zticks([-1.0, 0.0, 1.0])
ax2.zaxis.set_major_formatter(FormatStrFormatter('%.1f'))
ax2.xaxis.set_major_locator(plt.MultipleLocator(np.pi / 2))
ax2.xaxis.set_minor_locator(plt.MultipleLocator(np.pi / 6))
ax2.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter()))
ax2.yaxis.set_major_locator(plt.MultipleLocator(np.pi / 2))
ax2.yaxis.set_minor_locator(plt.MultipleLocator(np.pi / 6))
ax2.yaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter()))
ax2.zaxis.set_minor_locator(plt.MultipleLocator(0.5))
ax2.tick_params(axis='x', which='major', pad=-5)
ax2.tick_params(axis='y', which='major', pad=-5)
plt.savefig('angulardependencefinal.pdf')
plt.show()