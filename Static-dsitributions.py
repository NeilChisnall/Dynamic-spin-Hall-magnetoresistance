""" Script to calcaulet the numeric and analytic"""


import numpy as np 
from scipy.integrate import solve_bvp
import matplotlib.pyplot as plt 
from numba import njit

plt.rcParams["font.family"] = "Times New Roman"
plt.rcParams['font.size'] = '14'


# define all contstants

rho = 8.6e-7 #resistivity
sigma = 1/rho
lsf = 1.5e-9 #spin-diffusion length
e = 1.6e-19 #electron charge
thetaSH = 0.1 #spin hall angle
jc_in = 1 # input charge curretn density
jSHs0 = thetaSH * jc_in #spin current generated by SHE
Gr = 5e14 #real spin-mixing conductance, 0.0 for single layer/parallel magnetisation
Gi = 5e13j #im spin mixing
G = Gr + Gi
t_N = 5e-9 #heavy metal thickness
thetaXY = 0 # the in plane angle to the y axis
thetaZ = 0 # the out of plane angle (angle between XY plane and magnetisation)
mx = np.sin(thetaXY * np.pi / 180.00) #magnetisation direction unit vector components
my = np.cos(thetaXY * np.pi / 180.00)
mz = np.sin(thetaZ * np.pi / 180.00)
m = np.array([mx, my, mz], dtype=np.float64)
m_hat = m / np.linalg.norm(m)

mu_s = np.zeros((3), dtype=np.float64)
j_s = np.zeros((3), dtype=np.float64)
y_hat = np.array([0, 1, 0])
muSN0 = 2 * e * lsf * rho * jSHs0 * np.tanh(t_N / ( 2 * lsf))

#experiment parameters

# coupled ODE parameters
A = - 1 / (2 * rho)
B = e * jSHs0 # spin accumulation at the interface in the absence of spin transfer
C = lsf ** 2

## NUMERIC ->

# The two coupled diff eq are split into 6 (3per eq) coupled lin equations 
def fun(x, y):
    """ Defines the coupled ODEs for the spin current and spin accumulation 
        which is then solved by the BVP solver. The A, B, and C constants are
        defined above. """

    return np.vstack((
        A * y[3] / C,
        A * y[4] / C,
        A * y[5] / C, 
        y[0] / A,
        (y[1] + B) / A,
        y[2] / A
    ))

def bc(ya, yb):
    """ Boundary conditions as described in Chen et al. 
    (https://iopscience.iop.org/article/10.1088/0953-8984/28/10/103004)"""

    mus0 = np.array([ya[3], ya[4], ya[5]]) 
    eJs0 = Gr * np.cross(m_hat, np.cross(m_hat, mus0)) + np.absolute(Gi) * np.cross(m_hat, mus0)
    return np.array( [ ya[0] - eJs0[0], ya[1] - eJs0[1], ya[2] - eJs0[2], yb[0], yb[1], yb[2] ] )

#precision parameters and initial arrays for computation
n = 30
x = np.linspace(0, t_N, n)
y = np.zeros((6, x.size))
soln = solve_bvp(fun, bc, x, y) #initiallising and calling solver

if soln.status != 0:
    print("WARNING: sol.status is {}".format(soln.status))
print(soln.message)

"""---------------------------------------------------"""

## ANALYTIC ->
# The analytic solutions for the spin current and spin accumulation distributions
# as described in Chen et al. (https://iopscience.iop.org/article/10.1088/0953-8984/28/10/103004)
mu = np.zeros((3,n))
js = np.zeros((3,n))

def mu_func(z):

    mu_coeff = ( (2 * lsf * G ) / ( sigma + 2 * lsf * G * (1/np.tanh( (t_N) / (lsf) )) ) ) * ( (np.cosh( (z - t_N) / (lsf))) / (np.sinh( (t_N) / (lsf))))
    mu_s = ( -y_hat * ( ( np.sinh( (2*z - t_N) / (2*lsf) ) ) / ( np.sinh( (t_N) / (2*lsf) ) ) )
            + ( np.cross( m_hat, np.cross( m_hat , y_hat) ) * mu_coeff.real + np.cross( m_hat, y_hat) * mu_coeff.imag  ) )

    return mu_s   #note that mu_s is actually the normalised mu_s / mu_s0

def j_func(z):

    j_coeff = ( (2 * lsf * G * np.tanh( (t_N) / (2*lsf))) / ( sigma + 2 * lsf * G * (1/np.tanh( (t_N) / (lsf) )) ) ) * ( (np.sinh( (z - t_N) / (lsf))) / (np.sinh( (t_N) / (lsf)))) # the jumble of coeffs at the end
    j_s = (y_hat * ( ( np.cosh( (2*z - t_N) / (2*lsf) ) -  np.cosh( (t_N) / (2*lsf) ) ) / ( np.cosh( (t_N) / (2*lsf) ) ) )
            - ( np.cross( m_hat, np.cross( m_hat , y_hat) ) * j_coeff.real + np.cross( m_hat, y_hat) * j_coeff.imag  ) )
    return j_s  # normalised already

#runs the mu and js functions to calculate values for each z
for i in range(n):

    mu[:,i] = mu_func(x[i])
    js[:,i] = j_func(x[i])

## Plots ->

f = plt.figure(figsize=(8,6))
ax = f.add_subplot(111)

# analytic spin current only x and y components are plotted
plt.plot(x* 1e9, js[0],'tab:blue', label='$J_{sx}/J_{SH}$' )
plt.plot(x* 1e9, js[1],'tab:orange', label='$J_{sy}/J_{SH}$' )
# numeric spin current
plt.plot(soln.x* 1e9, soln.y[0] / B, 'kx' ) #computational values from solve bvp
plt.plot(soln.x* 1e9, soln.y[1] / B, 'kx')
#analytic spin accumulation
plt.plot(x* 1e9, mu[0,:], 'tab:blue' ,  label='$\mu_{sx}/\mu_s^0$')
plt.plot(x* 1e9, mu[1,:], 'tab:purple' , label='$\mu_{sy}/\mu_s^0$')
# numeric spin accumulation
plt.plot(soln.x* 1e9, soln.y[3] / muSN0, 'kx')
plt.plot(soln.x* 1e9, soln.y[4] / muSN0, 'kx')

plt.xlabel("z (nm)")
plt.ylim([-1,1])
plt.ylabel("Vacuum", fontsize=16)
ax.set_xticklabels([0,2,4,6,8,10])
plt.yticks([-1,0,1])

# saving data as CSV
# data = np.column_stack((x, js[0], js[1], js[2], mu[0], mu[1], mu[2], soln.y[0], soln.y[1], soln.y[2], soln.y[3], soln.y[4], soln.y[5]))
# description = str("JsMusGi0")
# np.savetxt( str(description + '.csv'), data, delimiter=',', header="x,jsx,jsy,jsz,mux,muy,muz,jsxn,jsyn,jszn,muxn,muyn,muzn")

plt.show()