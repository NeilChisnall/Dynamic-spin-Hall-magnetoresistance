""" Calulates the change in resistivity due to the spin-Hall effect in a bilayer 
    system. It determines the spin current and spin accumulation distributions by solving 
    the coupled spin diffusion equations as a boundary value problem. Then the spin current
    recoupled as charge current and averaged over the layer thickness. The analytic solutions
    for resistivity are then calculated as in Chen et al. 
    (https://iopscience.iop.org/article/10.1088/0953-8984/28/10/103004). """

import numpy as np 
from scipy.integrate import solve_bvp
import matplotlib.pyplot as plt 
from numba import jit, njit, vectorize
from scipy.integrate import simps


# physical constants
e = 1.602e-19 #electron charge
hbar = 1.0545718e-34

#intrinsic parameters
rho = 8.6e-7 #resistivity
sigma = 1/rho
lsf = 1.5e-9 #spin-diffusion length
thetaSH =  0.1 #spin hall angle
Gr = 5e14#real spin-mixing conductance, 0.0 for single layer/parallel magnetisation
Gi = 5e13j #im spin mixing
G = Gr + Gi

Ex = 10 #electromagnetic field strength in the x direction (arbitrary rn)
jSHs0 = thetaSH * Ex / rho #spin current generated by SHE
jc0 = sigma * Ex #charge current density
t_N = 5e-9 #heavy metal thickness
thetaXY = 45.00 # in plane angle between magnetisation and y axis
thetaZ = 0 # out of plane angle (angle between magnetisation and xy plane)
mx = np.sin(thetaXY * np.pi / 180.00) #magnetisation direction unit vector components
my = np.cos(thetaXY * np.pi / 180.00)
mz = np.sin(thetaZ * np.pi / 180.00)
m = np.array([mx, my, mz], dtype = np.float64) 
m_hat = m / np.linalg.norm(m)
#spin accumulation at the interface in the absence of spin transfer:
muSN0 = 2 * e * lsf * rho * jSHs0 * np.tanh(t_N / ( 2 * lsf)) 

# fun coefficients:
A = - 1 / (2 * rho)
B = e * jSHs0 # pure spin current induced by SHE
C = lsf ** 2

# The two coupled diff eq are split into 6 (3per eq) coupled lin equations 
@jit(nopython=True)
def fun(x, y):
    """  """

    return np.vstack((
        A * y[3] / C,
        A * y[4] / C,
        A * y[5] / C, 
        y[0] / A,
        (y[1] + B) / A,
        y[2] / A
    ))

# def boundary condtions

@jit(nopython=True)
def bc(ya, yb):

    
    mus0 = np.array([ya[3], ya[4], ya[5]])
    eJs0 = Gr * np.cross(m_hat, np.cross(m_hat, mus0)) + np.absolute(Gi) * np.cross(m_hat, mus0)
    return np.array( [ ya[0] - eJs0[0], ya[1] - eJs0[1], ya[2] - eJs0[2], yb[0], yb[1], yb[2] ] )

# bvp solver precission and array initialisation
n = 100
z = np.linspace(0, t_N, n)
y = np.zeros((6, z.size))

# calls Scipy solve_bvp function and outputs spin current and accumulation as a func of z
soln = solve_bvp(fun, bc, z, y) 
if soln.status != 0:
    print("WARNING: sol.status is {}".format(soln.status))
print(soln.message) # checks convergence

## Numeric Jc calulation ->
js = np.vstack(( soln.y[0], soln.y[1], soln.y[2])) / e
jc = np.zeros((3,n))

def Jc_Numeric():
    """ Iterates over each spatial point along the z axis and converts the
        spin current to charge current with an efficiency parameterised
        by thetaSH. """
    for l in range(n):
        jc[:,l] = thetaSH * (
            np.cross( js[:,l] , np.array([0.0, 0.0 ,1.0])))

    return jc

JcNumeric = Jc_Numeric()
JcLongNumeric = JcNumeric[0,:] + jc0 # SHE charge current + input charge current
JcTransNumeric = JcNumeric[1,:]

AvJcLong = np.average(JcLongNumeric) # averaging over layer thickness
AvJcTrans = np.average(JcTransNumeric)

rhoLongNumeric = Ex / AvJcLong # Numeric resistivities as described in Chen et al. 
rhoTransNumeric = -AvJcTrans / ( Ex * sigma**2 )

print("The Numeric longitudinal resitivity is: ", rhoLongNumeric )
print("The Numeric transverse resitivity is: ", rhoTransNumeric )

## analyic solution ->

@jit(nopython=True)
def Jc_Long_Analytic(z):

    j_coeff = ( (2 * lsf * G * np.tanh( (t_N) / (2*lsf))) / ( sigma + 2 * lsf * G * (1/np.tanh( (t_N) / (lsf) )) ) ) * ( (np.sinh( (z - t_N) / (lsf))) / (np.sinh( (t_N) / (lsf))))
    JclongAnaly = 1 + thetaSH**2 * ( ( (np.cosh( (2*z - t_N) / (2*lsf) ) - np.cosh( (t_N) / (2*lsf) ) ) / ( np.cosh( (t_N) / (2*lsf) )) ) + (1-m_hat[1]**2) * j_coeff.real )

    return JclongAnaly * jc0

@jit(nopython=True)
def Jc_Trans_Analytic(z):

    j_coeff = ( (2 * lsf * G * np.tanh( (t_N) / (2*lsf))) / ( sigma + 2 * lsf * G * (1/np.tanh( (t_N) / (lsf) )) ) ) * ( (np.sinh( (z - t_N) / (lsf))) / (np.sinh( (t_N) / (lsf))))
    JctransAnaly = thetaSH**2 * (m_hat[0] * m_hat[1] * j_coeff.real - m_hat[2] * j_coeff.imag)

    return JctransAnaly * jc0

# analytic resistivity
rho_coeff = ( ( 2*lsf*G*(np.tanh(t_N/(2*lsf)))**2 ) / (sigma + 2*lsf*G*(1/np.tanh(t_N/lsf))) )
deltaRho0 = - rho * thetaSH**2 * (2*lsf/t_N) * np.tanh(t_N/(2*lsf))
deltaRho1 = rho *thetaSH**2 * (lsf/t_N) * rho_coeff.real
deltaRho2 = - rho * thetaSH**2 * (lsf/t_N) * rho_coeff.imag

rhoLongAn =  rho + deltaRho0 + deltaRho1 * (1-m_hat[1]**2)
rhoTransAn = deltaRho1 * m_hat[0] * m_hat[1] + deltaRho2 * m_hat[2]


print("The Analytic longitudinal resitivity is: ", rhoLongAn )
print("The Analytic transverse resitivity is: ", rhoTransAn )
# percentage difference between numeric and analytic solutions
longPercDiff = 100 * np.absolute(rhoLongAn - rhoLongNumeric) * 2 / (rhoLongNumeric + rhoLongAn)
transPercDiff = 100 * np.absolute(rhoTransAn - rhoTransNumeric) * 2 / (rhoTransNumeric + rhoTransAn)
print(longPercDiff)
print(transPercDiff)

z *= 1e9 # z in nanometers
plt.subplot(2,1,1)
plt.plot(z, JcLongNumeric, 'kx', label='$J_{long}^{Numeric}/J{c}^{0}$')
plt.plot(z, Jc_Long_Analytic(z / 1e9), label='$J_{long}^{Analytic}/J{c}^{0}$')
plt.legend()
plt.ylabel("Jc Longitudinal")
plt.xlabel("")

plt.subplot(2,1,2)
plt.plot(z, JcTransNumeric, 'kx', label='$J_{trans}^{Numeric}/J{c}^{0}$')
plt.plot(z, Jc_Trans_Analytic(z / 1e9), label='$J_{trans}^{Analytic}/J{c}^{0}$')
plt.legend()
plt.ylabel("Jc Transverse")
plt.xlabel("z (nm)")
plt.show()